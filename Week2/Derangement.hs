module Derangement where

import TestFunctions
import Permutations
import Data.List
import System.Random

--
-- Time spent: 8 hours
-- Test report:
--   - Succes on lists generated by getDerangement
--   - Different input sizes are handled correctly
--   - Empty lists are handled correctly
--   - Wrong elements are handled correctly (as defined by wrongElements)

perms :: [a] ->[[a]]					-- Perms function from week 1
perms [] = [[]]
perms (x:xs) = concat (map (insrt x) (perms xs)) where
  insrt x [] = [[x]]
  insrt x (y:ys) = (x:y:ys) : map (y:) (insrt x ys)

--
-- Actual functions
--
deran :: Eq a => [a] -> [[a]]				-- Could take an integer but was not sure if they wanted a list as param
deran n = filter (\ p -> 				-- Take only the derangements
  		isDerangement p n) 			-- Check if permutation is derangement
  		(perms n)				-- Get all the permutations

isDerangement :: Eq a => [a] -> [a] -> Bool		-- No need to check for [] [] because perms should do that and zipWith will fail anyway
isDerangement x y = and(zipWith (/=) x y)		-- Check if indexes are equal
		&& isPermutation x y			-- Has to be a permutation

--
-- define some testable properties for the isDerangement function
--
wrongElements :: Num a => ([a] -> [a] -> Bool) -> Bool  -- Should handle wrong lists
wrongElements n = not( n [2] [1] ) && not( n [1] [2] )	-- Expected: True \todo: Not sure if we need the second case
		    
nothing :: ([a] -> [a] -> Bool) -> Bool			-- Should be capable of handling empty lists
nothing n = n [] []					-- Expected: True, should be handled in perms

deltaSize :: Num a => ([a] -> [a] -> Bool) -> Bool	-- Check if it accounts for different sizes
deltaSize n = not( n [1] [] ) && not( n [] [1] )	-- Expected: True, should fail in the func

--
-- Automate the whole thing into tests
-- hehe: http://stackoverflow.com/questions/8416365/generate-a-random-integer-in-a-range-in-haskell
--       ^ This avoids using all the monad IO terror
createDerangement :: Eq a => Int -> [a] -> [a]		-- Might return a derangement of the list
createDerangement n xs = (deran xs)!!n			-- Get the derangement list at index n, n should be random probably

getDerangement :: (Eq a, Show a) => [a] -> IO()
getDerangement xs = do
                 g <- newStdGen                         -- Seed the random gen
		 let t = fst(randomR(0, length xs) g)	-- We use fst here because randomR is a pair with val, generator for some reason 
                 print(createDerangement t xs)       	-- return random derangement

-- Now just feed these functions to the test ones
